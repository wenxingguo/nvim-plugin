"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderManager = void 0;
const coc_nvim_1 = require("coc.nvim");
const path_1 = __importDefault(require("path"));
const types_1 = require("./types");
const util_1 = require("./util");
class ProviderManager {
    constructor(channel, subscriptions, configuration) {
        this.channel = channel;
        this.subscriptions = subscriptions;
        this.configuration = configuration;
        this.providers = new Map();
        this.subscriptions.push(coc_nvim_1.Disposable.create(() => {
            this.providers.clear();
        }));
    }
    regist(provider, name) {
        this.providers.set(name, provider);
        return coc_nvim_1.Disposable.create(() => {
            this.providers.delete(name);
        });
    }
    get hasProvider() {
        return this.providers.size > 0;
    }
    async init() {
        var _a;
        let providers = Array.from(this.providers.values());
        await Promise.allSettled(providers.map(provider => provider.init().catch(e => {
            coc_nvim_1.workspace.nvim.echoError(e);
            this.appendError('Error on provider init:', e);
        })));
        let promises = [];
        coc_nvim_1.workspace.documents.forEach(doc => {
            let filetype = (0, util_1.getSnippetFiletype)(doc);
            promises.push(this.loadSnippetsByFiletype(filetype));
        });
        let filetype;
        let doc = (_a = coc_nvim_1.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document;
        if (doc)
            filetype = doc.filetype;
        coc_nvim_1.window.onDidChangeActiveTextEditor(async (e) => {
            var _a;
            let newFiletype = (_a = e.document) === null || _a === void 0 ? void 0 : _a.filetype;
            if (newFiletype && newFiletype != filetype) {
                filetype = newFiletype;
                let bufnr = e.document.bufnr;
                await Promise.allSettled(providers.map(provider => provider.onFiletypeChange(bufnr, filetype).catch(e => {
                    this.appendError('Error on filetype change:', e);
                })));
            }
        }, null, this.subscriptions);
        coc_nvim_1.workspace.onDidOpenTextDocument(async (doc) => {
            let filetype = (0, util_1.getSnippetFiletype)({ bufnr: doc.bufnr, filetype: doc.languageId });
            await this.loadSnippetsByFiletype(filetype);
        }, null, this.subscriptions);
        await Promise.allSettled(promises);
    }
    async loadSnippetsByFiletype(filetype) {
        let promises = [];
        for (let [name, provider] of this.providers.entries()) {
            promises.push(provider.loadSnippetsByFiletype(filetype).catch(e => {
                this.appendError(`Error on load "${name}" snippets:`, e);
            }));
        }
        await Promise.allSettled(promises);
    }
    getSnippets(filetype) {
        let names = Array.from(this.providers.keys());
        let list = [];
        for (let name of names) {
            let provider = this.providers.get(name);
            try {
                let snippets = provider.getSnippets(filetype);
                snippets.map(s => s.provider = name);
                list.push(...snippets);
            }
            catch (e) {
                this.appendError(`getSnippets of ${name}`, e);
            }
        }
        list.sort((a, b) => {
            if (a.filetype != b.filetype && (a.filetype == filetype || b.filetype == filetype)) {
                return a.filetype == filetype ? -1 : 1;
            }
            if (a.priority != b.priority) {
                return b.priority - a.priority;
            }
            if (a.filepath != b.filepath) {
                return b.filepath > a.filepath ? 1 : -1;
            }
            return a.lnum - b.lnum;
        });
        return list;
    }
    async getSnippetFiles(filetype) {
        let files = [];
        for (let [name, provider] of this.providers.entries()) {
            try {
                let res = await provider.getSnippetFiles(filetype);
                files = files.concat(res);
            }
            catch (e) {
                this.appendError(`getSnippetFiles of ${name}`, e);
            }
        }
        return files;
    }
    async getTriggerSnippets(bufnr, autoTrigger = false, position) {
        let doc = coc_nvim_1.workspace.getDocument(bufnr);
        if (!doc)
            return [];
        if (!position)
            position = await coc_nvim_1.window.getCursorPosition();
        let names = Array.from(this.providers.keys());
        let list = [];
        for (let name of names) {
            let provider = this.providers.get(name);
            try {
                let items = await provider.getTriggerSnippets(doc, position, autoTrigger);
                for (let item of items) {
                    list.push(Object.assign({ source: name }, item));
                }
            }
            catch (e) {
                this.appendError(`get trigger snippets of ${name}`, e);
            }
        }
        list.sort((a, b) => b.priority - a.priority);
        if (list.length > 1) {
            let priority = list[0].priority;
            list = list.filter(o => o.priority == priority);
        }
        return list;
    }
    appendError(name, e) {
        this.channel.appendLine(`[Error ${(new Date()).toLocaleTimeString()}] Error on ${name}: ${typeof e === 'string' ? e : e.message}`);
        if (e instanceof Error) {
            this.channel.appendLine(e.stack);
        }
    }
    checkSyntax(syntax) {
        var _a;
        let syntaxes = (_a = this.configuration.inspect('disableSyntaxes').globalValue) !== null && _a !== void 0 ? _a : [];
        if (syntaxes.length == 0)
            return true;
        try {
            for (let str of syntaxes) {
                let r = new RegExp(str, 'i');
                if (r.test(syntax))
                    return false;
            }
        }
        catch (e) {
            // ignore
        }
        return true;
    }
    async provideCompletionItems(document, position, _token, context) {
        var _a, _b, _c;
        let doc = coc_nvim_1.workspace.getDocument(document.uri);
        if (!doc || !this.checkSyntax(context.option.synname))
            return [];
        let bufnr = doc.bufnr;
        let filetype = (0, util_1.getSnippetFiletype)(doc);
        let snippets = this.getSnippets(filetype);
        let currline = doc.getline(position.line, true);
        let { input, col, line, colnr } = context.option;
        let character = (0, util_1.characterIndex)(line, col);
        let before_content = currline.slice(0, character);
        let after = line.slice((0, util_1.characterIndex)(line, colnr - 1));
        let res = [];
        let noneWords = before_content.endsWith(' ') ? '' : before_content.match(/\W*$/)[0];
        let contextPrefixes = [];
        const execContext = (_a = this.configuration.inspect('execContext').globalValue) !== null && _a !== void 0 ? _a : false;
        for (let snip of snippets) {
            if (!execContext && snip.context)
                continue;
            if (snip.prefix === '')
                continue;
            if (input.length == 0 && (!snip.special || !before_content.endsWith(snip.special)))
                continue;
            if (contextPrefixes.indexOf(snip.prefix) !== -1)
                continue;
            let contentBefore = before_content;
            if (snip.context) {
                let provider = this.providers.get(snip.provider);
                let valid;
                try {
                    valid = await provider.checkContext(snip.context);
                }
                catch (e) {
                    this.appendError(`checkContext of ${snip.provider}`, e);
                    valid = false;
                }
                if (!valid)
                    continue;
                contextPrefixes.push(snip.prefix);
            }
            let head = this.getPrefixHead(doc, snip.prefix);
            let ultisnip = snip.provider == 'ultisnips' || snip.provider == 'snipmate';
            let startCharacter = character;
            let item = {
                label: snip.prefix,
                kind: coc_nvim_1.CompletionItemKind.Snippet,
                filterText: snip.prefix,
                detail: snip.description,
                insertTextFormat: coc_nvim_1.InsertTextFormat.Snippet
            };
            // check common begin for special characters
            if (noneWords && snip.special) {
                if (noneWords.endsWith(snip.special)) {
                    let len = snip.special.length;
                    item.filterText = item.filterText.slice(len);
                    startCharacter = character - len;
                    contentBefore = contentBefore.slice(0, -len);
                }
                else {
                    continue;
                }
            }
            item.data = {
                bufnr,
                snip,
                provider: snip.provider,
                filepath: `${path_1.default.basename(snip.filepath)}:${snip.lnum}`
            };
            if (ultisnip) {
                // range line
                // before_content snip.prefix
                let formatOptions = (_b = snip.formatOptions) !== null && _b !== void 0 ? _b : {};
                let actions = (_c = snip.actions) !== null && _c !== void 0 ? _c : {};
                item.data.ultisnip = {
                    actions,
                    context: snip.context,
                    regex: snip.originRegex,
                    range: coc_nvim_1.Range.create(position.line, startCharacter, position.line, character + snip.prefix.length),
                    line: before_content + snip.prefix + after,
                    noExpand: formatOptions.noExpand,
                    trimTrailingWhitespace: formatOptions.trimTrailingWhitespace,
                    removeWhiteSpace: formatOptions.removeWhiteSpace
                };
            }
            if (snip.regex) {
                if (!input.length || snip.prefix && input[0] != snip.prefix[0])
                    continue;
                let content = before_content + snip.prefix;
                let ms = content.match(snip.regex);
                if (!ms)
                    continue;
            }
            else if (head && before_content.endsWith(head)) {
                contentBefore = before_content.slice(0, -head.length);
                Object.assign(item, {
                    textEdit: {
                        range: coc_nvim_1.Range.create({ line: position.line, character: startCharacter }, position),
                        newText: snip.prefix
                    }
                });
            }
            else if (input.length == 0) {
                // let { special } = snip
                // contentBefore = before_content.slice(0, - special.length)
                Object.assign(item, {
                    preselect: true,
                    textEdit: {
                        range: coc_nvim_1.Range.create({ line: position.line, character: startCharacter }, position),
                        newText: snip.prefix
                    }
                });
            }
            if (snip.triggerKind == types_1.TriggerKind.LineBegin && contentBefore.trim().length)
                continue;
            if (snip.triggerKind == types_1.TriggerKind.SpaceBefore) {
                if (contentBefore.length && !/\s/.test(contentBefore[contentBefore.length - 1])) {
                    continue;
                }
            }
            if (!item.textEdit) {
                item.textEdit = {
                    range: coc_nvim_1.Range.create({ line: position.line, character: startCharacter }, position),
                    newText: snip.prefix
                };
            }
            res.push(item);
        }
        return res;
    }
    async resolveCompletionItem(item) {
        let provider = this.providers.get(item.data.provider);
        if (provider) {
            let doc = coc_nvim_1.workspace.getDocument(item.data.bufnr);
            let filetype = doc ? doc.filetype : undefined;
            let insertSnippet = item.data.snip.body;
            if (coc_nvim_1.snippetManager && insertSnippet) {
                if (typeof provider.resolveSnippetBody === 'function') {
                    insertSnippet = await Promise.resolve(provider.resolveSnippetBody(insertSnippet));
                }
                item.textEdit.newText = insertSnippet;
                let resolved = await coc_nvim_1.snippetManager.resolveSnippet(insertSnippet, item.data.ultisnip);
                if (typeof resolved !== 'string') {
                    coc_nvim_1.window.showErrorMessage(`Please upgrade your coc.nvim to use coc-snippets`);
                    return;
                }
                let ms = filetype === null || filetype === void 0 ? void 0 : filetype.match(/^\w+/);
                let block = (0, util_1.markdownBlock)(resolved, ms == null ? 'txt' : ms[0]);
                item.documentation = {
                    kind: 'markdown',
                    value: block + (item.data.filepath ? `\n${item.data.filepath}` : '')
                };
            }
        }
        return item;
    }
    getPrefixHead(doc, prefix) {
        let res = 0;
        for (let idx = prefix.length - 1; idx >= 0; idx--) {
            if (!doc.isWord(prefix[idx])) {
                res = idx;
                break;
            }
        }
        return res == 0 ? '' : prefix.slice(0, res + 1);
    }
}
exports.ProviderManager = ProviderManager;
