"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const readline_1 = __importDefault(require("readline"));
const types_1 = require("./types");
const util_1 = require("./util");
function fixFiletype(filetype) {
    if (filetype === 'javascript_react')
        return 'javascriptreact';
    return filetype;
}
const actionMap = {
    'pre_expand': 'preExpand',
    'post_expand': 'postExpand',
    'post_jump': 'postJump'
};
class UltiSnipsParser {
    constructor(channel, trace = false) {
        this.channel = channel;
        this.trace = trace;
    }
    parseUltisnipsFile(filetype, filepath) {
        const rl = readline_1.default.createInterface({
            input: fs_1.default.createReadStream(filepath, 'utf8'),
            crlfDelay: Infinity
        });
        let actions = [];
        let pycodes = [];
        let snippets = [];
        let block;
        let preLines = [];
        let first;
        let priority = 0;
        let lnum = 0;
        let clearsnippets = null;
        let parsedContext = null;
        let extendFiletypes = [];
        rl.on('line', line => {
            lnum += 1;
            if (!block && (line.startsWith('#') || line.length == 0))
                return;
            const [head, tail] = (0, util_1.headTail)(line);
            if (!block) {
                switch (head) {
                    case 'priority':
                        let n = parseInt(tail.trim(), 10);
                        if (!isNaN(n))
                            priority = n;
                        break;
                    case 'extends':
                        let fts = tail.trim().split(/,\s+/);
                        for (let ft of fts) {
                            ft = fixFiletype(ft);
                            if (extendFiletypes.indexOf(ft) == -1) {
                                extendFiletypes.push(ft);
                            }
                        }
                        break;
                    case 'pre_expand':
                    case 'post_expand':
                    case 'post_jump':
                        actions.push(line);
                        break;
                    case 'clearsnippets':
                        clearsnippets = priority;
                        break;
                    case 'context':
                        parsedContext = tail.replace(/^"(.+)"$/, '$1');
                        break;
                    case 'snippet':
                    case 'global':
                        block = head;
                        first = tail;
                        break;
                }
                return;
            }
            if (head == 'endglobal' && block == 'global') {
                block = null;
                pycodes.push(`# ${lnum - preLines.length}`, ...preLines);
                preLines = [];
                return;
            }
            if (head == 'endsnippet' && block == 'snippet') {
                block = null;
                try {
                    let body = preLines.join('\n');
                    let ms = first.match(/^(.+?)(?:\s+(?:"(.*?)")?(?:\s+"(.*?)")?(?:\s+(\w+))?)?\s*$/);
                    let description = ms[2] || '';
                    let option = ms[4] || '';
                    let trigger = (0, util_1.getTriggerText)(ms[1], option.includes('r'));
                    let regex = null;
                    let originRegex;
                    let triggers = [];
                    if (option.indexOf('r') !== -1) {
                        originRegex = trigger;
                        let pattern = (0, util_1.convertRegex)(trigger);
                        if (pattern.endsWith('$'))
                            pattern = pattern.slice(0, -1);
                        regex = new RegExp(`(?:${pattern})$`);
                        // get the real text
                        let parsed = (0, util_1.getRegexText)(trigger);
                        if (!parsed.includes('|')) {
                            triggers.push(parsed);
                        }
                        else {
                            // parse to words
                            triggers = parsed.split(/\|/);
                        }
                    }
                    else {
                        triggers.push(trigger);
                    }
                    for (let prefix of triggers) {
                        let pm = prefix.match(/^\W+/);
                        let snippet = {
                            originRegex,
                            context: parsedContext ? parsedContext : (option.includes('e') ? ms[3] : undefined),
                            filepath,
                            filetype,
                            prefix: prefix,
                            special: pm == null ? undefined : pm[0],
                            autoTrigger: option.indexOf('A') !== -1,
                            lnum: lnum - preLines.length - 2,
                            triggerKind: getTriggerKind(option),
                            description,
                            regex,
                            body,
                            priority,
                            actions: {},
                            formatOptions: {
                                noExpand: option.includes('t'),
                                trimTrailingWhitespace: option.includes('m'),
                                removeWhiteSpace: option.includes('s')
                            }
                        };
                        while (actions.length) {
                            const line = actions.pop();
                            const [head, tail] = (0, util_1.headTail)(line);
                            let key = actionMap[head];
                            if (key) {
                                snippet.actions[key] = (0, util_1.trimQuote)(tail);
                            }
                            else {
                                this.error(`Unknown UltiSnips action: ${head}`);
                            }
                        }
                        this.debug(`Loaded snippet`, snippet);
                        snippets.push(snippet);
                    }
                }
                catch (e) {
                    this.error(`Create snippet error on: ${filepath}:${lnum - preLines.length - 1} ${e.message}`);
                }
                finally {
                    parsedContext = null;
                    preLines = [];
                }
            }
            if (block == 'snippet' || block == 'global') {
                preLines.push(line);
                return;
            }
        });
        return new Promise(resolve => {
            rl.on('close', async () => {
                resolve({ snippets, clearsnippets, pythonCode: pycodes.join('\n'), extendFiletypes });
            });
        });
    }
    error(str) {
        if (!this.channel)
            return;
        this.channel.appendLine(`[Error ${(new Date()).toLocaleTimeString()}] ${str}`);
    }
    debug(str, data) {
        if (!this.channel || !this.trace)
            return;
        this.channel.appendLine(`[Debug ${(new Date()).toLocaleTimeString()}] ${str}: ${JSON.stringify(data, null, 2)}`);
    }
}
exports.default = UltiSnipsParser;
function getTriggerKind(option) {
    if (option.indexOf('i') !== -1 || option === 'r') {
        return types_1.TriggerKind.InWord;
    }
    if (option.indexOf('w') !== -1) {
        return types_1.TriggerKind.WordBoundary;
    }
    if (option.indexOf('b') !== -1) {
        return types_1.TriggerKind.LineBegin;
    }
    return types_1.TriggerKind.SpaceBefore;
}
