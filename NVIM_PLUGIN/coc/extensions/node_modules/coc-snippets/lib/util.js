"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filetypeFromBasename = exports.normalizeFilePath = exports.omit = exports.languageIdFromComments = exports.characterIndex = exports.fileStartsWith = exports.sameFile = exports.fixDriver = exports.isParentFolder = exports.waitDocument = exports.markdownBlock = exports.getTriggerText = exports.getRegexText = exports.convertRegex = exports.distinct = exports.trimQuote = exports.memorize = exports.headTail = exports.readdirAsync = exports.statAsync = exports.flatten = exports.replaceText = exports.documentation = exports.createMD5 = exports.uid = exports.getSnippetFiletype = exports.getAllAdditionalFiletype = exports.getAdditionalFiletype = exports.addFiletypes = exports.insertSnippetEdit = exports.setLastSnippet = exports.pythonCodes = void 0;
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const coc_nvim_1 = require("coc.nvim");
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
exports.pythonCodes = new Map();
const caseInsensitive = os_1.default.platform() == 'win32' || os_1.default.platform() == 'darwin';
const BASE64 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_';
const additionalFiletypes = new Map();
var lastSnippet = undefined;
function setLastSnippet(snip) {
}
exports.setLastSnippet = setLastSnippet;
async function insertSnippetEdit(edit) {
    var _a;
    let ultisnips = edit.source == 'ultisnips' || edit.source == 'snipmate';
    let option;
    if (ultisnips) {
        let formatOptions = (_a = edit.formatOptions) !== null && _a !== void 0 ? _a : {};
        option = {
            regex: edit.regex,
            actions: edit.actions,
            context: edit.context,
            noExpand: formatOptions.noExpand,
            trimTrailingWhitespace: formatOptions.trimTrailingWhitespace,
            removeWhiteSpace: formatOptions.removeWhiteSpace
        };
    }
    await coc_nvim_1.commands.executeCommand('editor.action.insertSnippet', coc_nvim_1.TextEdit.replace(edit.range, edit.newText), option);
}
exports.insertSnippetEdit = insertSnippetEdit;
function addFiletypes(bufnr, filetypes) {
    var _a;
    let curr = (_a = additionalFiletypes.get(bufnr)) !== null && _a !== void 0 ? _a : [];
    filetypes.forEach(filetype => {
        if (filetype && !curr.includes(filetype))
            curr.push(filetype);
    });
    additionalFiletypes.set(bufnr, curr);
}
exports.addFiletypes = addFiletypes;
function getAdditionalFiletype(bufnr) {
    var _a;
    return (_a = additionalFiletypes.get(bufnr)) !== null && _a !== void 0 ? _a : [];
}
exports.getAdditionalFiletype = getAdditionalFiletype;
function getAllAdditionalFiletype() {
    let filetypes = [];
    coc_nvim_1.workspace.documents.forEach(doc => {
        let arr = getAdditionalFiletype(doc.bufnr);
        if (arr.length)
            filetypes.push(...arr);
    });
    return filetypes;
}
exports.getAllAdditionalFiletype = getAllAdditionalFiletype;
function getSnippetFiletype(doc) {
    let filetypes = getAdditionalFiletype(doc.bufnr);
    return [doc.filetype, ...filetypes].join('.');
}
exports.getSnippetFiletype = getSnippetFiletype;
function tostr(bytes) {
    let r = [];
    let i;
    for (i = 0; i < bytes.length; i++) {
        r.push(BASE64[bytes[i] % 64]);
    }
    return r.join('');
}
function uid() {
    return tostr(crypto_1.default.randomBytes(10));
}
exports.uid = uid;
function createMD5(input) {
    return crypto_1.default.createHash('md5').update(input).digest('hex');
}
exports.createMD5 = createMD5;
exports.documentation = `# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly $\{1} = new Emitter<$2>()
#		public readonly $\{1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt
`;
function replaceText(content, items) {
    let res = '';
    items.sort((a, b) => a.index - b.index);
    let item = items.shift();
    for (let i = 0; i < content.length; i++) {
        let idx = item ? item.index : null;
        if (idx == null || i != idx) {
            res = res + content[i];
            continue;
        }
        res = res + item.newText;
        i = i + item.length;
    }
    return res;
}
exports.replaceText = replaceText;
function flatten(arr) {
    return arr.reduce((p, curr) => p.concat(curr), []);
}
exports.flatten = flatten;
async function statAsync(filepath) {
    try {
        return await (0, util_1.promisify)(fs_1.default.stat)(filepath);
    }
    catch (e) {
        return null;
    }
}
exports.statAsync = statAsync;
async function readdirAsync(filepath) {
    try {
        return await (0, util_1.promisify)(fs_1.default.readdir)(filepath);
    }
    catch (e) {
        return null;
    }
}
exports.readdirAsync = readdirAsync;
function headTail(line) {
    line = line.trim();
    let ms = line.match(/^(\S+)\s+(.*)/);
    if (!ms)
        return [line, ''];
    return [ms[1], ms[2]];
}
exports.headTail = headTail;
function memorize(_target, key, descriptor) {
    let fn = descriptor.get;
    if (typeof fn !== 'function')
        return;
    let memoKey = '$' + key;
    descriptor.get = function (...args) {
        if (this.hasOwnProperty(memoKey))
            return Promise.resolve(this[memoKey]);
        return new Promise((resolve, reject) => {
            Promise.resolve(fn.apply(this, args)).then(res => {
                this[memoKey] = res;
                resolve(res);
            }, e => {
                reject(e);
            });
        });
    };
}
exports.memorize = memorize;
function trimQuote(str) {
    if (/^(["']).*\1$/.test(str))
        return str.slice(1, -1);
    return str;
}
exports.trimQuote = trimQuote;
function distinct(array, keyFn) {
    if (!keyFn) {
        return array.filter((element, position) => {
            return array.indexOf(element) === position;
        });
    }
    const seen = Object.create(null);
    return array.filter(elem => {
        const key = keyFn(elem);
        if (seen[key]) {
            return false;
        }
        seen[key] = true;
        return true;
    });
}
exports.distinct = distinct;
const stringStartRe = /\\A/;
const conditionRe = /\(\?\(\w+\).+\|/;
const commentRe = /\(\?#.*?\)/;
const namedCaptureRe = /\(\?P<\w+>.*?\)/;
const namedReferenceRe = /\(\?P=(\w+)\)/;
const regex = new RegExp(`${commentRe.source}|${stringStartRe.source}|${namedCaptureRe.source}|${namedReferenceRe.source}`, 'g');
/**
 * Convert python regex to javascript regex,
 * throw error when unsupported pattern found
 *
 * @public
 * @param {string} str
 * @returns {string}
 */
function convertRegex(str) {
    if (str.indexOf('\\z') !== -1) {
        throw new Error('pattern \\z not supported');
    }
    if (str.indexOf('(?s)') !== -1) {
        throw new Error('pattern (?s) not supported');
    }
    if (str.indexOf('(?x)') !== -1) {
        throw new Error('pattern (?x) not supported');
    }
    if (str.indexOf('\n') !== -1) {
        throw new Error('multiple line pattern not supported');
    }
    if (conditionRe.test(str)) {
        throw new Error('(?id/name)yes-pattern|no-pattern not supported');
    }
    return str.replace(regex, (match, p1) => {
        if (match.startsWith('(?#'))
            return '';
        if (match == '\\A')
            return '^';
        if (match.startsWith('(?P<'))
            return '(?' + match.slice(3);
        if (match.startsWith('(?P='))
            return `\\k<${p1}>`;
        return '';
    });
}
exports.convertRegex = convertRegex;
function getRegexText(prefix) {
    if (prefix.startsWith('^'))
        prefix = prefix.slice(1);
    if (prefix.endsWith('$'))
        prefix = prefix.slice(0, -1);
    // keep word inside ()?
    let content = prefix.replace(/\((\w+)\)\?/g, '$1').replace(/\(.*\)\??/g, '');
    content = content.replace(/\\/g, '');
    return content;
}
exports.getRegexText = getRegexText;
function getTriggerText(text, regex) {
    if (!text || /\w/.test(text[0]) || text.length <= 2)
        return text !== null && text !== void 0 ? text : '';
    if (text[0] == text[text.length - 1] && (regex || text.includes(' ') || text[0] == '/'))
        return text.slice(1, -1);
    return text;
}
exports.getTriggerText = getTriggerText;
function markdownBlock(code, filetype) {
    filetype = filetype == 'javascriptreact' ? 'javascript' : filetype;
    filetype = filetype == 'typescriptreact' ? 'typescript' : filetype;
    return '``` ' + filetype + '\n' + code + '\n```';
}
exports.markdownBlock = markdownBlock;
async function waitDocument(doc, changedtick) {
    if (doc.changedtick >= changedtick)
        return Promise.resolve(doc.changedtick === changedtick);
    return new Promise(resolve => {
        let timeout = setTimeout(() => {
            disposable.dispose();
            resolve(doc.changedtick == changedtick);
        }, 200);
        let disposable = doc.onDocumentChange(() => {
            clearTimeout(timeout);
            disposable.dispose();
            resolve(doc.changedtick == changedtick);
        });
    });
}
exports.waitDocument = waitDocument;
function isParentFolder(folder, filepath, checkEqual = false) {
    let pdir = fixDriver(path_1.default.resolve(path_1.default.normalize(folder)));
    let dir = fixDriver(path_1.default.resolve(path_1.default.normalize(filepath)));
    if (pdir == '//')
        pdir = '/';
    if (sameFile(pdir, dir))
        return checkEqual ? true : false;
    if (pdir.endsWith(path_1.default.sep))
        return fileStartsWith(dir, pdir);
    return fileStartsWith(dir, pdir) && dir[pdir.length] == path_1.default.sep;
}
exports.isParentFolder = isParentFolder;
// use uppercase for windows driver
function fixDriver(filepath, platform = os_1.default.platform()) {
    if (platform != 'win32' || filepath[1] != ':')
        return filepath;
    return filepath[0].toUpperCase() + filepath.slice(1);
}
exports.fixDriver = fixDriver;
function sameFile(fullpath, other) {
    if (!fullpath || !other)
        return false;
    if (caseInsensitive)
        return fullpath.toLowerCase() === other.toLowerCase();
    return fullpath === other;
}
exports.sameFile = sameFile;
function fileStartsWith(dir, pdir) {
    if (caseInsensitive)
        return dir.toLowerCase().startsWith(pdir.toLowerCase());
    return dir.startsWith(pdir);
}
exports.fileStartsWith = fileStartsWith;
function characterIndex(content, byteIndex) {
    let buf = Buffer.from(content, 'utf8');
    return buf.slice(0, byteIndex).toString('utf8').length;
}
exports.characterIndex = characterIndex;
function languageIdFromComments(lines) {
    for (let i = 0; i < Math.min(5, lines.length); i++) {
        let ms = lines[i].match(/^\s*\/\/\sPlace\syour\s(\w+)\sworkspace/);
        if (ms)
            return ms[1];
    }
    return undefined;
}
exports.languageIdFromComments = languageIdFromComments;
function omit(obj, properties) {
    let o = {};
    for (let key of Object.keys(obj)) {
        if (!properties.includes(key)) {
            o[key] = obj[key];
        }
    }
    return o;
}
exports.omit = omit;
function normalizeFilePath(filepath) {
    return coc_nvim_1.Uri.file(path_1.default.resolve(path_1.default.normalize(filepath))).fsPath;
}
exports.normalizeFilePath = normalizeFilePath;
function filetypeFromBasename(basename) {
    if (basename == 'typescript_react')
        return 'typescriptreact';
    if (basename == 'javascript_react')
        return 'javascriptreact';
    if (basename.includes('_'))
        return basename.split('_', 2)[0];
    return basename.split('-', 2)[0];
}
exports.filetypeFromBasename = filetypeFromBasename;
