"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextmateProvider = void 0;
const coc_nvim_1 = require("coc.nvim");
const fs_1 = __importDefault(require("fs"));
const jsonc_parser_1 = require("jsonc-parser");
const path_1 = __importDefault(require("path"));
const baseProvider_1 = __importDefault(require("./baseProvider"));
const types_1 = require("./types");
const util_1 = require("./util");
class TextmateProvider extends baseProvider_1.default {
    constructor(channel, config, subscriptions) {
        super(config, channel);
        this.config = config;
        this.subscriptions = subscriptions;
        this.loadedFiles = new Set();
        this.loadedSnippets = [];
        this.loadedLanguageIds = new Set();
        this.definitions = new Map();
        this.loadedRoots = new Set();
    }
    async init() {
        if (this.config.loadFromExtensions) {
            for (let extension of coc_nvim_1.extensions.all) {
                this.loadSnippetDefinition(extension).then(items => {
                    if (items === null || items === void 0 ? void 0 : items.length) {
                        items = items.filter(o => o.languageIds.includes('all') || o.languageIds.some(id => coc_nvim_1.workspace.languageIds.has(id)));
                        this.loadSnippetsFromDefinition(extension.id, items);
                    }
                }, e => {
                    this.error(`Error on load textmate snippets: ${e.message}`, e.stack);
                });
            }
            coc_nvim_1.extensions.onDidLoadExtension(extension => {
                this.loadSnippetDefinition(extension).then(items => {
                    if (items === null || items === void 0 ? void 0 : items.length) {
                        items = items.filter(o => o.languageIds.includes('all') || o.languageIds.some(id => coc_nvim_1.workspace.languageIds.has(id)));
                        this.loadSnippetsFromDefinition(extension.id, items);
                    }
                }, e => {
                    this.error(`Error on load textmate snippets: ${e.message}`, e.stack);
                });
            }, null, this.subscriptions);
            coc_nvim_1.extensions.onDidUnloadExtension(id => {
                this.loadedSnippets = this.loadedSnippets.filter(item => {
                    return item.extensionId !== id;
                });
            }, null, this.subscriptions);
        }
        let paths = this.config.snippetsRoots;
        for (let dir of paths !== null && paths !== void 0 ? paths : []) {
            await this.loadDefinitionFromRoot(dir);
        }
        if (this.config.projectSnippets) {
            coc_nvim_1.workspace.workspaceFolders.forEach(folder => {
                let fsPath = coc_nvim_1.Uri.parse(folder.uri).fsPath;
                void this.loadFromWorkspace(fsPath);
            });
            coc_nvim_1.workspace.onDidChangeWorkspaceFolders(e => {
                e.removed.forEach(folder => {
                    let fsPath = coc_nvim_1.Uri.parse(folder.uri).fsPath;
                    this.loadedSnippets = this.loadedSnippets.filter(o => {
                        return !o.filepath.startsWith(fsPath + path_1.default.sep);
                    });
                });
                e.added.forEach(folder => {
                    let fsPath = coc_nvim_1.Uri.parse(folder.uri).fsPath;
                    void this.loadFromWorkspace(fsPath);
                });
            });
        }
    }
    async loadFromWorkspace(fsPath) {
        let root = path_1.default.join(fsPath, '.vscode');
        await this.loadDefinitionFromRoot(root, false);
    }
    async loadSnippetsByFiletype(languageId) {
        if (this.loadedLanguageIds.has(languageId))
            return;
        let filetypes = this.getFiletypes(languageId);
        this.info(`Loading textmate snippets from filetypes: ${filetypes.join(', ')}`);
        for (let languageId of filetypes) {
            if (this.loadedLanguageIds.has(languageId))
                continue;
            this.loadedLanguageIds.add(languageId);
            for (let [extensionId, items] of this.definitions.entries()) {
                for (let item of items) {
                    if (!item.languageIds.includes(languageId))
                        continue;
                    await this.loadSnippetsFromFile(item.filepath, item.languageIds, extensionId);
                }
            }
        }
    }
    async getSnippetFiles(filetype) {
        let filetypes = this.getFiletypes(filetype);
        filetypes.push('all');
        let filepaths = [];
        for (let def of this.loadedSnippets) {
            if (filepaths.includes(def.filepath))
                continue;
            if (def.filetypes.some(ft => filetypes.includes(ft))) {
                filepaths.push(def.filepath);
            }
        }
        return filepaths;
    }
    async getTriggerSnippets(document, position, autoTrigger) {
        var _a;
        if (autoTrigger)
            return [];
        let line = document.getline(position.line);
        line = line.slice(0, position.character);
        let snippets = this.getDocumentSnippets(document);
        if (!snippets || !snippets.length)
            return [];
        let edits = [];
        for (let snip of snippets) {
            let { prefix } = snip;
            if (!line.endsWith(prefix))
                continue;
            let pre = line.slice(0, line.length - prefix.length);
            // not allowed after word
            if (pre.length && /\w/.test(pre[pre.length - 1]))
                continue;
            edits.push({
                prefix,
                range: coc_nvim_1.Range.create(position.line, position.character - prefix.length, position.line, position.character),
                newText: snip.body,
                location: snip.filepath,
                lnum: snip.lnum,
                description: snip.description,
                priority: (_a = snip.priority) !== null && _a !== void 0 ? _a : -1
            });
        }
        return edits;
    }
    getSnippets(filetype) {
        let res = [];
        let filetypes = this.getFiletypes(filetype);
        filetypes.push('all');
        for (let def of this.loadedSnippets) {
            if (filetypes.some(ft => def.filetypes.includes(ft))) {
                let languageId = def.filetypes.includes(filetype) ? filetype : def.filetypes.find(ft => filetypes.includes(ft));
                res.push(...toSnippets(def, languageId));
            }
        }
        res.sort((a, b) => {
            if (a.filetype != b.filetype) {
                if (a.filetype == filetype || b.filetype == filetype) {
                    return a.filetype == filetype ? -1 : 1;
                }
                if (a.filetype == 'all' || b.filetype == 'all') {
                    return a.filetype == 'all' ? 1 : -1;
                }
                if (a.priority != b.priority) {
                    return b.priority - a.priority;
                }
                return 0;
            }
        });
        let filtered = [];
        for (let item of res) {
            // consider the same by prefix & description
            if (!filtered.find(o => o.prefix == item.prefix && o.description == item.description)) {
                filtered.push(item);
            }
        }
        // this.info('filtered:', filtered)
        return filtered;
    }
    async loadSnippetDefinition(extension) {
        let { packageJSON } = extension;
        const arr = [];
        if (packageJSON.contributes && packageJSON.contributes.snippets) {
            let { snippets } = packageJSON.contributes;
            const extensionId = extension.id;
            for (let item of snippets) {
                let p = path_1.default.join(extension.extensionPath, item.path);
                let exists = arr.find(o => o.filepath == p);
                let languages = Array.isArray(item.language) ? item.language : [item.language];
                if (exists) {
                    languages.forEach(s => {
                        if (!exists.languageIds.includes(s)) {
                            exists.languageIds.push(s);
                        }
                    });
                    continue;
                }
                if (fs_1.default.existsSync(p))
                    arr.push({ languageIds: languages, filepath: p });
            }
            if (snippets && snippets.length) {
                this.definitions.set(extensionId, arr);
            }
        }
        return arr;
    }
    async loadDefinitionFromRoot(configPath, showWarningMessage = true) {
        var _a;
        let root = coc_nvim_1.workspace.expand(configPath);
        let stat = await (0, util_1.statAsync)(root);
        if (!stat || !stat.isDirectory()) {
            if (showWarningMessage)
                this.warn(`${configPath} not a valid directory.`);
            return;
        }
        root = (0, util_1.normalizeFilePath)(root);
        if (this.loadedRoots.has(root))
            return;
        this.loadedRoots.add(root);
        let files = await fs_1.default.promises.readdir(root, 'utf8');
        files = files.filter(f => f.endsWith('.json') || f.endsWith('.code-snippets'));
        let items = (_a = this.definitions.get('')) !== null && _a !== void 0 ? _a : [];
        for (let file of files) {
            let filepath = path_1.default.join(root, file);
            if (file.endsWith('.code-snippets')) {
                this.info(`Loading global snippets from: ${filepath}`);
                // Don't know languageId, load all of them
                await this.loadSnippetsFromFile(filepath, undefined, undefined);
            }
            else {
                let basename = path_1.default.basename(file, '.json');
                items.push({ languageIds: [basename], filepath });
            }
        }
        this.definitions.set('', items);
    }
    async loadSnippetsFromDefinition(extensionId, items) {
        for (let item of items) {
            if (!fs_1.default.existsSync(item.filepath))
                continue;
            await this.loadSnippetsFromFile(item.filepath, item.languageIds, extensionId);
        }
    }
    async loadSnippetsFromFile(snippetFilePath, languageIds, extensionId) {
        if (this.isLoaded(snippetFilePath) || this.isIgnored(snippetFilePath))
            return;
        let contents;
        try {
            contents = await fs_1.default.promises.readFile(snippetFilePath, 'utf8');
        }
        catch (e) {
            this.error(`Error on readFile "${snippetFilePath}": ${e.message}`);
            return;
        }
        try {
            this.loadSnippetsFromText(snippetFilePath, extensionId, languageIds, contents);
        }
        catch (e) {
            this.error(`Error on load snippets from "${snippetFilePath}": ${e.message}`, e.stack);
        }
    }
    isLoaded(filepath) {
        for (let file of this.loadedFiles) {
            if ((0, util_1.sameFile)(file, filepath)) {
                return true;
            }
        }
        return false;
    }
    loadSnippetsFromText(filepath, extensionId, ids, contents) {
        let snippets = [];
        let commentLanguageId;
        let isGlobal = isGlobalSnippet(filepath);
        this.loadedFiles.add(filepath);
        try {
            let errors = [];
            let lines = contents.split(/\r?\n/);
            if (isGlobal)
                commentLanguageId = (0, util_1.languageIdFromComments)(lines);
            let snippetObject = (0, jsonc_parser_1.parse)(contents, errors, { allowTrailingComma: true });
            if (errors.length)
                this.error(`Parse error of ${filepath}`, errors);
            if (snippetObject) {
                for (let key of Object.keys(snippetObject)) {
                    let p = '"' + key + '"';
                    let idx = lines.findIndex(line => line.trim().startsWith(p));
                    let lnum = idx == -1 ? 0 : idx;
                    snippets.push(Object.assign({ lnum }, snippetObject[key]));
                }
            }
        }
        catch (ex) {
            this.error(`Error on parse "${filepath}": ${ex.message}`, ex.stack);
            return;
        }
        const normalizedSnippets = [];
        snippets.forEach((snip) => {
            if (!snip.prefix)
                return;
            let languageIds;
            if (ids && ids.length > 0) {
                languageIds = ids;
            }
            else if (isGlobal) {
                languageIds = snip.scope ? snip.scope.split(',') : undefined;
                if (!languageIds && commentLanguageId)
                    languageIds = [commentLanguageId];
            }
            if (!languageIds && isGlobal)
                languageIds = ['all'];
            let obj = {
                prefixes: Array.isArray(snip.prefix) ? snip.prefix : [snip.prefix],
                filetypes: languageIds,
                extensionId,
                filepath,
                lnum: snip.lnum,
                body: typeof snip.body === 'string' ? snip.body : snip.body.join('\n'),
                description: getDescription(snip.description),
                triggerKind: types_1.TriggerKind.WordBoundary,
                priority: languageIds.includes('all') ? -60 : extensionId ? -2 : -1
            };
            normalizedSnippets.push(obj);
            this.trace(`Snippet:`, obj);
        });
        this.loadedSnippets.push(...normalizedSnippets);
        this.info(`Loaded ${normalizedSnippets.length} textmate snippets from ${filepath}`, ids);
    }
}
exports.TextmateProvider = TextmateProvider;
function getDescription(description) {
    if (typeof description === 'string')
        return description;
    if (Array.isArray(description) && description.every(s => typeof s === 'string'))
        return description.join('\n');
    return undefined;
}
function toSnippets(def, languageId) {
    return def.prefixes.map(prefix => {
        return Object.assign((0, util_1.omit)(def, ['filetypes', 'prefixes']), {
            prefix,
            filetype: languageId,
        });
    });
}
function isGlobalSnippet(filepath) {
    return filepath.endsWith('.code-snippets');
}
