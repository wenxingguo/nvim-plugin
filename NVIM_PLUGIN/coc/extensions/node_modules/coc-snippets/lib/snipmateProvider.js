"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnipmateProvider = void 0;
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const coc_nvim_1 = require("coc.nvim");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const readline_1 = __importDefault(require("readline"));
const baseProvider_1 = __importDefault(require("./baseProvider"));
const types_1 = require("./types");
const util_1 = require("./util");
function convertBody(body) {
    return body.replace(/`(.*?)(?<!\\)`/g, (_, p1) => {
        if (p1.startsWith('Filename(')) {
            p1 = p1.replace(/^Filename/, 'vim_snippets#Filename');
        }
        return '`!v ' + p1 + '`';
    });
}
class SnipmateProvider extends baseProvider_1.default {
    constructor(channel, config, subscriptions) {
        super(config, channel);
        this.config = config;
        this.subscriptions = subscriptions;
        this.fileItems = [];
        this.snippetFiles = [];
        this.loadedLanguageIds = new Set();
        coc_nvim_1.workspace.onDidSaveTextDocument(async (doc) => {
            let uri = coc_nvim_1.Uri.parse(doc.uri);
            if (uri.scheme != 'file')
                return;
            let filepath = uri.fsPath;
            if (!fs_1.default.existsSync(filepath))
                return;
            let idx = this.snippetFiles.findIndex(s => (0, util_1.sameFile)(s.filepath, filepath));
            if (idx !== -1) {
                let filetype = this.snippetFiles[idx].filetype;
                this.snippetFiles.splice(idx, 1);
                await this.loadSnippetsFromFile(filetype, filepath);
            }
        }, null, this.subscriptions);
    }
    async init() {
        let { nvim } = coc_nvim_1.workspace;
        let author = await nvim.getVar('snips_author');
        if (!author)
            nvim.setVar('snips_author', this.config.author, true);
        this.fileItems = await this.loadAllSnippetFiles();
        coc_nvim_1.workspace.onDidRuntimePathChange(async (e) => {
            for (let rtp of e) {
                let items = await this.getSnippetFileItems(path_1.default.join(rtp, 'snippets'));
                if (items === null || items === void 0 ? void 0 : items.length) {
                    this.fileItems.push(...items);
                    for (let item of items) {
                        if (coc_nvim_1.workspace.filetypes.has(item.filetype)) {
                            await this.loadSnippetsFromFile(item.filetype, item.filepath);
                        }
                    }
                }
            }
        }, null, this.subscriptions);
    }
    async loadSnippetsByFiletype(filetype) {
        let filetypes = filetype ? this.getFiletypes(filetype) : [];
        filetypes.push('_');
        filetypes = filetypes.filter(filetype => !this.loadedLanguageIds.has(filetype));
        if (filetypes.length == 0)
            return;
        filetypes.forEach(filetype => this.loadedLanguageIds.add(filetype));
        for (let item of this.fileItems) {
            if (!filetypes.includes(item.filetype))
                continue;
            await this.loadSnippetsFromFile(item.filetype, item.filepath);
        }
    }
    async loadSnippetsFromFile(filetype, filepath) {
        let idx = this.snippetFiles.findIndex(o => (0, util_1.sameFile)(o.filepath, filepath));
        if (idx !== -1)
            return;
        idx = this.fileItems.findIndex(o => o.filepath == filepath);
        if (idx !== -1)
            this.fileItems.splice(idx, 1);
        if (this.isIgnored(filepath))
            return;
        let res = await this.parseSnippetsFile(filetype, filepath);
        if (this.snippetFiles.findIndex(o => (0, util_1.sameFile)(o.filepath, filepath)) == -1) {
            this.snippetFiles.push({ filepath, filetype, snippets: res.snippets });
            this.info(`Loaded ${res.snippets.length} ${filetype} snipmate snippets from: ${filepath}`);
            if (res.extends.length) {
                let fts = res.extends;
                let curr = this.config.extends[filetype] || [];
                for (let ft of fts) {
                    await this.loadSnippetsByFiletype(ft);
                    if (!curr.includes(ft)) {
                        curr.push(ft);
                    }
                }
                this.config.extends[filetype] = curr;
            }
        }
    }
    /**
     * Parse snippets from snippets file.
     */
    parseSnippetsFile(filetype, filepath) {
        let res = [];
        let extendsFiletypes = [];
        const rl = readline_1.default.createInterface({
            input: fs_1.default.createReadStream(filepath, 'utf8'),
            crlfDelay: Infinity
        });
        let lnum = 0;
        let lines = [];
        let prefix = '';
        let description = '';
        rl.on('line', line => {
            lnum += 1;
            if (line.startsWith('#'))
                return;
            if (/^extends\s/.test(line)) {
                let ft = line.replace(/^extends\s+/, '');
                if (ft)
                    extendsFiletypes.push(ft);
                return;
            }
            if (line.startsWith('snippet')) {
                line = line.replace(/\s*$/, '');
                if (lines.length && prefix) {
                    let body = lines.join('\n').replace(/\s+$/, '');
                    res.push({
                        filepath,
                        filetype,
                        lnum: lnum - lines.length - 1,
                        body: convertBody(body),
                        prefix,
                        description,
                        triggerKind: types_1.TriggerKind.WordBoundary,
                        provider: 'snipmate'
                    });
                    lines = [];
                }
                let ms = line.match(/^snippet\s+(\S+)(?:\s(.+))?$/);
                if (!ms) {
                    prefix = '';
                    this.error(`Broken line on ${filepath}:${lnum}`);
                    return;
                }
                prefix = ms[1];
                description = ms[2] || '';
                return;
            }
            if (prefix) {
                if (line.startsWith('\t')) {
                    lines.push(line.slice(1));
                }
                else {
                    lines.push(line);
                }
            }
        });
        return new Promise(resolve => {
            rl.on('close', async () => {
                if (lines.length) {
                    let body = lines.join('\n').replace(/\s+$/, '');
                    res.push({
                        filepath,
                        lnum: lnum - lines.length - 1,
                        filetype,
                        body: convertBody(body),
                        prefix,
                        description,
                        triggerKind: types_1.TriggerKind.WordBoundary
                    });
                }
                this.trace('snipmate snippets', res);
                resolve({ snippets: res, extends: extendsFiletypes });
            });
        });
    }
    async getTriggerSnippets(document, position, autoTrigger) {
        if (autoTrigger)
            return [];
        let snippets = this.getDocumentSnippets(document);
        let line = document.getline(position.line);
        line = line.slice(0, position.character);
        if (!line)
            return [];
        snippets = snippets.filter(s => {
            let { prefix } = s;
            if (!line.endsWith(prefix))
                return false;
            let pre = line.slice(0, line.length - prefix.length);
            return pre.length == 0 || !document.isWord(pre[pre.length - 1]);
        });
        let edits = [];
        for (let s of snippets) {
            let character = position.character - s.prefix.length;
            let range = coc_nvim_1.Range.create(position.line, character, position.line, position.character);
            edits.push({
                prefix: s.prefix,
                description: s.description,
                location: s.filepath,
                lnum: s.lnum,
                range,
                newText: s.body,
                priority: -1
            });
        }
        return edits;
    }
    async getSnippetFiles(filetype) {
        let filetypes = filetype ? this.getFiletypes(filetype) : [];
        filetypes.push('_');
        let res = [];
        for (let s of this.snippetFiles) {
            if (filetypes.indexOf(s.filetype) !== -1) {
                res.push(s.filepath);
            }
        }
        return res;
    }
    getSnippets(filetype) {
        let filetypes = this.getFiletypes(filetype);
        filetypes.push('_');
        let snippetFiles = this.snippetFiles.filter(o => filetypes.includes(o.filetype));
        let result = [];
        snippetFiles.sort((a, b) => {
            if (a.filetype == b.filetype)
                return 1;
            if (a.filetype == filetype)
                return -1;
            return 1;
        });
        for (let file of snippetFiles) {
            let { snippets } = file;
            for (let snip of snippets) {
                result.push(snip);
            }
        }
        return result;
    }
    async loadAllSnippetFiles() {
        let { env } = coc_nvim_1.workspace;
        let rtps = env.runtimepath.split(',');
        let res = [];
        for (let rtp of rtps) {
            let items = await this.getSnippetFileItems(path_1.default.join(rtp, 'snippets'));
            res.push(...items);
        }
        return res;
    }
    async getSnippetFileItems(directory) {
        let res = [];
        let stat = await (0, util_1.statAsync)(directory);
        if (stat && stat.isDirectory()) {
            let files = await (0, util_1.readdirAsync)(directory);
            if (files.length) {
                for (let f of files) {
                    let file = path_1.default.join(directory, f);
                    if (file.endsWith('.snippets')) {
                        let basename = path_1.default.basename(f, '.snippets');
                        let filetype = basename.split('-', 2)[0];
                        res.push({ filepath: file, directory, filetype });
                    }
                    else {
                        let stat = await (0, util_1.statAsync)(file);
                        if (stat && stat.isDirectory()) {
                            let files = await (0, util_1.readdirAsync)(file);
                            for (let filename of files) {
                                if (filename.endsWith('.snippets')) {
                                    res.push({ filepath: path_1.default.join(file, filename), directory, filetype: f });
                                }
                            }
                        }
                    }
                }
            }
        }
        return res;
    }
}
exports.SnipmateProvider = SnipmateProvider;
